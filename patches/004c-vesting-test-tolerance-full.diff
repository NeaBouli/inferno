*** Begin Patch
*** Delete File: test/Vesting.test.js
*** End Patch
*** Begin Patch
*** Add File: test/Vesting.test.js
+const { expect } = require("chai");
+const { ethers } = require("hardhat");
+
+describe("Vesting", function () {
+  let deployer, beneficiary, guardian, other;
+  let token, vesting;
+
+  const DECIMALS = 9;
+  const toUnits = (n) => ethers.utils.parseUnits(n.toString(), DECIMALS);
+
+  const CLIFF = 90 * 24 * 3600;       // 90 Tage
+  const DURATION = 365 * 24 * 3600;   // 12 Monate
+  const ALLOCATION = toUnits(1_000_000); // 1 Mio. IFR
+
+  beforeEach(async () => {
+    [deployer, beneficiary, guardian, other] = await ethers.getSigners();
+
+    // Mock-Token verwenden
+    const Token = await ethers.getContractFactory("MockInfernoToken");
+    token = await Token.deploy();
+    await token.deployed();
+
+    const Vesting = await ethers.getContractFactory("Vesting");
+    vesting = await Vesting.deploy(
+      token.address,
+      beneficiary.address,
+      CLIFF,
+      DURATION,
+      ALLOCATION,
+      guardian.address
+    );
+    await vesting.deployed();
+
+    // Vesting mit Tokens befüllen
+    await (await token.transfer(vesting.address, ALLOCATION)).wait();
+  });
+
+  async function increaseTime(seconds) {
+    await ethers.provider.send("evm_increaseTime", [seconds]);
+    await ethers.provider.send("evm_mine", []);
+  }
+
+  it("verhindert Release vor Cliff", async () => {
+    await expect(vesting.connect(beneficiary).release()).to.be.reverted;
+  });
+
+  it("releast linear nach dem Cliff", async () => {
+    await increaseTime(CLIFF + 30 * 24 * 3600);
+    const releasable = await vesting.releasableAmount();
+    expect(releasable).to.be.gt(0);
+
+    const balBefore = await token.balanceOf(beneficiary.address);
+    await expect(vesting.connect(beneficiary).release()).to.emit(vesting, "Released");
+    const balAfter = await token.balanceOf(beneficiary.address);
+
+    // Erlaube minimale Rundungsdifferenzen (±1)
+    const diff = balAfter.sub(balBefore).sub(releasable).abs();
+    expect(diff).to.be.lte(1);
+  });
+
+  it("gibt alles am Ende frei", async () => {
+    await increaseTime(DURATION + 1);
+    const releasable = await vesting.releasableAmount();
+    expect(releasable).to.equal(ALLOCATION);
+    await expect(vesting.connect(beneficiary).release()).to.emit(vesting, "Released");
+    const contractBal = await token.balanceOf(vesting.address);
+    expect(contractBal).to.equal(0);
+  });
+
+  it("nur Beneficiary darf release() aufrufen", async () => {
+    await increaseTime(DURATION + 1);
+    await expect(vesting.connect(other).release()).to.be.reverted;
+  });
+
+  it("Guardian kann pausieren und fortsetzen", async () => {
+    await increaseTime(DURATION / 2);
+    await expect(vesting.connect(guardian).pause()).to.emit(vesting, "Paused");
+    await expect(vesting.connect(beneficiary).release()).to.be.reverted;
+    await expect(vesting.connect(guardian).unpause()).to.emit(vesting, "Unpaused");
+    await expect(vesting.connect(beneficiary).release()).to.emit(vesting, "Released");
+  });
+});
*** End Patch
