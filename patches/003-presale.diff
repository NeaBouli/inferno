*** Begin Patch
diff --git a/contracts/presale/Presale.sol b/contracts/presale/Presale.sol
new file mode 100644
--- /dev/null
+++ b/contracts/presale/Presale.sol
@@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.20;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
+import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
+
+/**
+ * @title Inferno Presale
+ * @notice ETH â†’ IFR Presale. ETH wird unmittelbar an Treasury weitergeleitet,
+ *         IFR aus dem Contract-Bestand an KÃ¤ufer transferiert.
+ *
+ * WICHTIG: Presale-Contract muss im Token als feeExempt gesetzt werden.
+ */
+contract Presale is Ownable, Pausable, ReentrancyGuard {
+    IERC20 public immutable token;
+    address public treasury;
+
+    uint256 public priceWeiPerToken; // ETH in Wei pro 1 IFR (9 decimals)
+    uint256 public minContribution;
+    uint256 public maxContribution;
+    uint256 public hardCap;
+
+    uint256 public phaseId;
+    uint256 public phaseCap;
+    uint256 public phaseRaised;
+    uint256 public totalRaised;
+
+    mapping(address => uint256) public contributed;
+
+    event Purchased(address indexed buyer, uint256 ethIn, uint256 ifrOut, uint256 indexed phaseId);
+    event PhaseUpdated(uint256 indexed phaseId, uint256 priceWeiPerToken, uint256 phaseCapWei);
+    event TreasuryUpdated(address indexed newTreasury);
+
+    error ZeroAddress();
+    error InvalidParams();
+    error CapExceeded();
+    error InsufficientTokens();
+
+    constructor(
+        address _owner,
+        IERC20 _token,
+        address _treasury,
+        uint256 _priceWeiPerToken,
+        uint256 _minContribution,
+        uint256 _maxContribution,
+        uint256 _hardCap,
+        uint256 _phaseCap
+    ) Ownable(_owner) {
+        if (address(_token) == address(0) || _treasury == address(0)) revert ZeroAddress();
+        if (_priceWeiPerToken == 0) revert InvalidParams();
+        if (_maxContribution > 0 && _minContribution > _maxContribution) revert InvalidParams();
+        if (_hardCap == 0) revert InvalidParams();
+
+        token = _token;
+        treasury = _treasury;
+        priceWeiPerToken = _priceWeiPerToken;
+        minContribution = _minContribution;
+        maxContribution = _maxContribution;
+        hardCap = _hardCap;
+        phaseCap = _phaseCap;
+    }
+
+    function buy() external payable whenNotPaused nonReentrant {
+        uint256 ethIn = msg.value;
+        if (ethIn == 0) revert InvalidParams();
+
+        if (minContribution > 0 && ethIn < minContribution) revert InvalidParams();
+        uint256 newTotalUser = contributed[msg.sender] + ethIn;
+        if (maxContribution > 0 && newTotalUser > maxContribution) revert CapExceeded();
+
+        uint256 newTotalRaised = totalRaised + ethIn;
+        if (newTotalRaised > hardCap) revert CapExceeded();
+        if (phaseCap > 0 && (phaseRaised + ethIn) > phaseCap) revert CapExceeded();
+
+        uint256 ifrOut = (ethIn * 1_000_000_000) / priceWeiPerToken; // 9 decimals
+        if (ifrOut == 0) revert InvalidParams();
+        if (token.balanceOf(address(this)) < ifrOut) revert InsufficientTokens();
+
+        contributed[msg.sender] = newTotalUser;
+        totalRaised = newTotalRaised;
+        phaseRaised += ethIn;
+
+        (bool ok, ) = payable(treasury).call{value: ethIn}("");
+        require(ok, "ETH forward failed");
+
+        require(token.transfer(msg.sender, ifrOut), "token transfer failed");
+        emit Purchased(msg.sender, ethIn, ifrOut, phaseId);
+    }
+
+    function setPhase(uint256 newPriceWeiPerToken, uint256 newPhaseCapWei) external onlyOwner {
+        if (newPriceWeiPerToken == 0) revert InvalidParams();
+        phaseId += 1;
+        priceWeiPerToken = newPriceWeiPerToken;
+        phaseCap = newPhaseCapWei;
+        phaseRaised = 0;
+        emit PhaseUpdated(phaseId, newPriceWeiPerToken, newPhaseCapWei);
+    }
+
+    function setTreasury(address _treasury) external onlyOwner {
+        if (_treasury == address(0)) revert ZeroAddress();
+        treasury = _treasury;
+        emit TreasuryUpdated(_treasury);
+    }
+}
diff --git a/testing/Presale.test.js b/testing/Presale.test.js
new file mode 100644
--- /dev/null
+++ b/testing/Presale.test.js
@@
+const { expect } = require("chai");
+const { ethers } = require("hardhat");
+
+describe("Presale", function () {
+  const UNIT = 10n ** 9n; // 9 decimals
+
+  let deployer, treasury, buyer, token, presale;
+
+  function quote(ethWei, priceWeiPerToken) {
+    return (ethWei * UNIT) / priceWeiPerToken;
+  }
+
+  beforeEach(async () => {
+    [deployer, treasury, buyer] = await ethers.getSigners();
+
+    const Token = await ethers.getContractFactory("ERC20PresetMinterPauser");
+    token = await Token.deploy("Inferno", "IFR");
+    await token.waitForDeployment();
+
+    const priceWeiPerToken = ethers.parseEther("0.0001"); // 0.0001 ETH per IFR
+    const minContribution = ethers.parseEther("0.05");
+    const maxContribution = ethers.parseEther("10");
+    const hardCap = ethers.parseEther("100");
+    const phaseCap = ethers.parseEther("50");
+
+    const Presale = await ethers.getContractFactory("Presale");
+    presale = await Presale.deploy(
+      deployer.address,
+      await token.getAddress(),
+      treasury.address,
+      priceWeiPerToken,
+      minContribution,
+      maxContribution,
+      hardCap,
+      phaseCap
+    );
+    await presale.waitForDeployment();
+
+    await token.mint(await presale.getAddress(), 1_000_000n * UNIT);
+  });
+
+  it("happy path: forwards ETH and sends IFR", async () => {
+    const price = await presale.getCurrentPrice().catch(() => ethers.parseEther("0.0001"));
+    const ethIn = ethers.parseEther("1");
+    const expectedIFR = quote(ethIn, price);
+
+    const tEthBefore = await ethers.provider.getBalance(treasury.address);
+    await expect(presale.connect(buyer).buy({ value: ethIn }))
+      .to.emit(presale, "Purchased");
+    const tEthAfter = await ethers.provider.getBalance(treasury.address);
+    expect(tEthAfter - tEthBefore).to.equal(ethIn);
+
+    const ifrBuyer = await token.balanceOf(buyer.address);
+    expect(ifrBuyer).to.equal(expectedIFR);
+  });
+});
diff --git a/scripts/deploy_presale.js b/scripts/deploy_presale.js
new file mode 100644
--- /dev/null
+++ b/scripts/deploy_presale.js
@@
+/* eslint-disable no-console */
+const hre = require("hardhat");
+
+async function main() {
+  const [deployer] = await hre.ethers.getSigners();
+  console.log("Deployer:", deployer.address);
+
+  const TOKEN_ADDRESS = process.env.TOKEN_ADDRESS;
+  const TREASURY_ADDRESS = process.env.TREASURY_ADDRESS;
+  const PRICE_WEI_PER_TOKEN = hre.ethers.toBigInt(process.env.PRICE_WEI_PER_TOKEN || "100000000000000"); // 0.0001 ETH
+  const MIN_CONTRIBUTION_WEI = hre.ethers.toBigInt(process.env.MIN_CONTRIBUTION_WEI || "50000000000000000"); // 0.05
+  const MAX_CONTRIBUTION_WEI = hre.ethers.toBigInt(process.env.MAX_CONTRIBUTION_WEI || "10000000000000000000"); // 10
+  const HARD_CAP_WEI = hre.ethers.toBigInt(process.env.HARD_CAP_WEI || "100000000000000000000"); // 100
+  const PHASE_CAP_WEI = hre.ethers.toBigInt(process.env.PHASE_CAP_WEI || "50000000000000000000"); // 50
+
+  if (!TOKEN_ADDRESS || !TREASURY_ADDRESS) {
+    throw new Error("TOKEN_ADDRESS and TREASURY_ADDRESS must be provided");
+  }
+
+  const Presale = await hre.ethers.getContractFactory("Presale");
+  const presale = await Presale.deploy(
+    deployer.address,
+    TOKEN_ADDRESS,
+    TREASURY_ADDRESS,
+    PRICE_WEI_PER_TOKEN,
+    MIN_CONTRIBUTION_WEI,
+    MAX_CONTRIBUTION_WEI,
+    HARD_CAP_WEI,
+    PHASE_CAP_WEI
+  );
+  await presale.waitForDeployment();
+  console.log("Presale deployed at:", await presale.getAddress());
+}
+
+main().catch((error) => {
+  console.error(error);
+  process.exitCode = 1;
+});
diff --git a/abi/Presale_v1.json b/abi/Presale_v1.json
new file mode 100644
--- /dev/null
+++ b/abi/Presale_v1.json
@@
+[
+  {
+    "inputs": [
+      { "internalType": "address", "name": "_owner", "type": "address" },
+      { "internalType": "address", "name": "_token", "type": "address" },
+      { "internalType": "address", "name": "_treasury", "type": "address" },
+      { "internalType": "uint256", "name": "_priceWeiPerToken", "type": "uint256" },
+      { "internalType": "uint256", "name": "_minContribution", "type": "uint256" },
+      { "internalType": "uint256", "name": "_maxContribution", "type": "uint256" },
+      { "internalType": "uint256", "name": "_hardCap", "type": "uint256" },
+      { "internalType": "uint256", "name": "_phaseCap", "type": "uint256" }
+    ],
+    "stateMutability": "nonpayable",
+    "type": "constructor"
+  },
+  { "inputs": [], "name": "buy", "outputs": [], "stateMutability": "payable", "type": "function" },
+  { "inputs": [], "name": "setPhase", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
+  { "inputs": [], "name": "setTreasury", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
+  { "inputs": [], "name": "treasury", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
+  { "inputs": [], "name": "phaseId", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
+  { "inputs": [], "name": "priceWeiPerToken", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
+]
diff --git a/docs/README.md b/docs/README.md
@@
-+â”‚   â”œâ”€â”€ ðŸ”µ presale/        
++â”‚   â”œâ”€â”€ ðŸŸ¢ presale/        
diff --git a/logs/project.log b/logs/project.log
@@
+[2025-09-22 23:59] Dev3 FEATURE â€“ Presale Contract + Tests + Deploy + ABI hinzugefÃ¼gt
*** End Patch
