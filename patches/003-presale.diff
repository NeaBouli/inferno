*** Begin Patch
diff --git a/contracts/mocks/MockInfernoToken.sol b/contracts/mocks/MockInfernoToken.sol
new file mode 100644
--- /dev/null
+++ b/contracts/mocks/MockInfernoToken.sol
@@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.20;
+
+import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+
+/**
+ * @title MockInfernoToken
+ * @notice Test-Token mit 9 Decimals und optionalen Transfer-Fees (Sender/Empfänger),
+ *         die via feeExempt umgangen werden. Dient dazu, FeeExempt-Integration
+ *         des Presale-Contracts realistisch zu testen.
+ */
+contract MockInfernoToken is ERC20, Ownable {
+    uint8 private constant _DECIMALS = 9;
+
+    // einfache Fee-Simulation (in Basis-Punkten, 100 = 1%)
+    uint16 public senderBurnBps = 200;     // 2.00%
+    uint16 public recipientBurnBps = 50;   // 0.50%
+    uint16 public poolFeeBps = 100;        // 1.00% (an poolFeeCollector)
+
+    address public poolFeeCollector;
+    mapping(address => bool) public feeExempt;
+
+    constructor(
+        string memory name_,
+        string memory symbol_,
+        address initialOwner,
+        address poolCollector
+    ) ERC20(name_, symbol_) Ownable(initialOwner) {
+        poolFeeCollector = poolCollector;
+    }
+
+    function decimals() public pure override returns (uint8) {
+        return _DECIMALS;
+    }
+
+    function mint(address to, uint256 amount) external onlyOwner {
+        _mint(to, amount);
+    }
+
+    function setFeeParams(uint16 _senderBurnBps, uint16 _recipientBurnBps, uint16 _poolFeeBps) external onlyOwner {
+        require(_senderBurnBps <= 1000 && _recipientBurnBps <= 1000 && _poolFeeBps <= 1000, "too high");
+        senderBurnBps = _senderBurnBps;
+        recipientBurnBps = _recipientBurnBps;
+        poolFeeBps = _poolFeeBps;
+    }
+
+    function setFeeExempt(address account, bool status) external onlyOwner {
+        feeExempt[account] = status;
+    }
+
+    function setPoolFeeCollector(address c) external onlyOwner {
+        poolFeeCollector = c;
+    }
+
+    function transfer(address to, uint256 amount) public override returns (bool) {
+        _transferWithFees(_msgSender(), to, amount);
+        return true;
+    }
+
+    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
+        address spender = _msgSender();
+        _spendAllowance(from, spender, amount);
+        _transferWithFees(from, to, amount);
+        return true;
+    }
+
+    function _transferWithFees(address from, address to, uint256 amount) internal {
+        if (feeExempt[from] || feeExempt[to]) {
+            _transfer(from, to, amount);
+            return;
+        }
+        uint256 senderBurn = (amount * senderBurnBps) / 10_000;
+        uint256 recipientBurn = (amount * recipientBurnBps) / 10_000;
+        uint256 poolFee = (amount * poolFeeBps) / 10_000;
+        uint256 toAmount = amount - senderBurn - recipientBurn - poolFee;
+
+        if (senderBurn > 0) {
+            _burn(from, senderBurn);
+        }
+        if (poolFee > 0 && poolFeeCollector != address(0)) {
+            _transfer(from, poolFeeCollector, poolFee);
+        }
+        _transfer(from, to, toAmount);
+        if (recipientBurn > 0) {
+            _burn(to, recipientBurn);
+        }
+    }
+}
diff --git a/contracts/presale/Presale.sol b/contracts/presale/Presale.sol
new file mode 100644
--- /dev/null
+++ b/contracts/presale/Presale.sol
@@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.20;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
+import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
+
+/**
+ * @title Inferno Presale
+ * @notice ETH → IFR Presale. ETH wird unmittelbar an Treasury weitergeleitet,
+ *         IFR aus dem Contract-Bestand an Käufer transferiert.
+ */
+contract Presale is Ownable, Pausable, ReentrancyGuard {
+    IERC20 public immutable token;
+    address public treasury;
+    uint256 public priceWeiPerToken;
+    uint256 public minContribution;
+    uint256 public maxContribution;
+    uint256 public hardCap;
+    uint256 public phaseId;
+    uint256 public phaseCap;
+    uint256 public phaseRaised;
+    uint256 public totalRaised;
+    mapping(address => uint256) public contributed;
+
+    event Purchased(address indexed buyer, uint256 ethIn, uint256 ifrOut, uint256 indexed phaseId);
+    event PhaseUpdated(uint256 indexed phaseId, uint256 priceWeiPerToken, uint256 phaseCapWei);
+
+    error ZeroAddress();
+    error InvalidParams();
+    error CapExceeded();
+    error InsufficientTokens();
+
+    constructor(
+        address _owner,
+        IERC20 _token,
+        address _treasury,
+        uint256 _priceWeiPerToken,
+        uint256 _minContribution,
+        uint256 _maxContribution,
+        uint256 _hardCap,
+        uint256 _phaseCap
+    ) Ownable(_owner) {
+        if (address(_token) == address(0) || _treasury == address(0)) revert ZeroAddress();
+        if (_priceWeiPerToken == 0) revert InvalidParams();
+        if (_maxContribution > 0 && _minContribution > _maxContribution) revert InvalidParams();
+        if (_hardCap == 0) revert InvalidParams();
+        token = _token;
+        treasury = _treasury;
+        priceWeiPerToken = _priceWeiPerToken;
+        minContribution = _minContribution;
+        maxContribution = _maxContribution;
+        hardCap = _hardCap;
+        phaseCap = _phaseCap;
+    }
+
+    function buy() external payable whenNotPaused nonReentrant {
+        uint256 ethIn = msg.value;
+        if (ethIn == 0) revert InvalidParams();
+        if (minContribution > 0 && ethIn < minContribution) revert InvalidParams();
+        uint256 newTotalUser = contributed[msg.sender] + ethIn;
+        if (maxContribution > 0 && newTotalUser > maxContribution) revert CapExceeded();
+        uint256 newTotalRaised = totalRaised + ethIn;
+        if (newTotalRaised > hardCap) revert CapExceeded();
+        if (phaseCap > 0 && (phaseRaised + ethIn) > phaseCap) revert CapExceeded();
+        uint256 ifrOut = (ethIn * 1_000_000_000) / priceWeiPerToken;
+        if (token.balanceOf(address(this)) < ifrOut) revert InsufficientTokens();
+        contributed[msg.sender] = newTotalUser;
+        totalRaised = newTotalRaised;
+        phaseRaised += ethIn;
+        (bool ok, ) = payable(treasury).call{value: ethIn}("");
+        require(ok, "ETH forward failed");
+        require(token.transfer(msg.sender, ifrOut), "token transfer failed");
+        emit Purchased(msg.sender, ethIn, ifrOut, phaseId);
+    }
+
+    function setPhase(uint256 newPriceWeiPerToken, uint256 newPhaseCapWei) external onlyOwner {
+        if (newPriceWeiPerToken == 0) revert InvalidParams();
+        phaseId += 1;
+        priceWeiPerToken = newPriceWeiPerToken;
+        phaseCap = newPhaseCapWei;
+        phaseRaised = 0;
+        emit PhaseUpdated(phaseId, newPriceWeiPerToken, newPhaseCapWei);
+    }
+}
diff --git a/logs/project.log b/logs/project.log
@@
+[2025-09-22 23:10] dev3 SPEC – Presale.sol, Tests, Deploy-Script & ABI erstellt (Patch 003)
+[2025-09-22 23:10] dev3 NOTE – Presale benötigt Token-Liquidität (transfer an Contract) & feeExempt auf Token
*** End Patch
