*** Begin Patch
diff --git a/contracts/buyback/BuybackVault.sol b/contracts/buyback/BuybackVault.sol
new file mode 100644
--- /dev/null
+++ b/contracts/buyback/BuybackVault.sol
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.20;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
+
+interface IUniV2RouterLike {
+    function WETH() external view returns (address);
+    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
+    function swapExactETHForTokens(
+        uint256 amountOutMin,
+        address[] calldata path,
+        address to,
+        uint256 deadline
+    ) external payable returns (uint256[] memory amounts);
+}
+
+/**
+ * @title BuybackVault
+ * @notice Nimmt ETH an und fÃ¼hrt manuelle Buybacks via Router aus.
+ *         Aufgeteilte IFR-Ausgabe: BurnReserve (burnShareBps) und Treasury (Rest).
+ *         EnthÃ¤lt Pause-Mechanik (kompatible Events/Revert-Message) und einfachen Reentrancy-Guard.
+ */
+contract BuybackVault is Ownable {
+    using SafeERC20 for IERC20;
+
+    // ---- Events ----
+    event Deposited(address indexed from, uint256 amount);
+    event BuybackExecuted(uint256 ethIn, uint256 ifrOut, uint256 burned, uint256 toTreasury);
+    event ParamsUpdated(uint256 burnShareBps, uint256 cooldown, uint256 slippageBps, address router, address treasury);
+    event GuardianUpdated(address indexed guardian);
+    event Paused(address account);
+    event Unpaused(address account);
+
+    // ---- Consts ----
+    uint256 private constant BPS_DENOMINATOR = 10_000;
+
+    // ---- Immutables ----
+    IERC20 public immutable IFR;
+    address public immutable burnReserve;
+
+    // ---- Configurable ----
+    address public treasury;
+    IUniV2RouterLike public router;
+    address public guardian;
+
+    uint256 public burnShareBps = 5_000; // 50%
+    uint256 public cooldown = 3_600;     // 1h
+    uint256 public slippageBps = 500;    // 5%
+
+    // ---- State ----
+    uint256 public lastBuybackAt;
+    bool private _paused;
+
+    // simple nonReentrant guard
+    uint256 private _entered; // 0 = not entered, 1 = entered
+
+    // ---- Modifiers ----
+    modifier onlyGuardianOrOwner() {
+        require(msg.sender == guardian || msg.sender == owner(), "not guardian/owner");
+        _;
+    }
+
+    modifier whenNotPaused() {
+        require(!_paused, "Pausable: paused");
+        _;
+    }
+
+    modifier nonReentrant() {
+        require(_entered == 0, "reentrancy");
+        _entered = 1;
+        _;
+        _entered = 0;
+    }
+
+    constructor(
+        address _ifr,
+        address _burnReserve,
+        address _treasury,
+        address _router,
+        address _guardian
+    ) {
+        require(_ifr != address(0), "ifr zero");
+        require(_burnReserve != address(0), "burn zero");
+        require(_treasury != address(0), "treasury zero");
+        require(_router != address(0), "router zero");
+
+        IFR = IERC20(_ifr);
+        burnReserve = _burnReserve;
+        treasury = _treasury;
+        router = IUniV2RouterLike(_router);
+        guardian = _guardian == address(0) ? msg.sender : _guardian;
+    }
+
+    // ---- ETH Ingress ----
+    receive() external payable {
+        emit Deposited(msg.sender, msg.value);
+    }
+
+    function depositETH() external payable whenNotPaused nonReentrant {
+        require(msg.value > 0, "no ETH");
+        emit Deposited(msg.sender, msg.value);
+    }
+
+    // ---- Core ----
+    function executeBuyback() external onlyOwner whenNotPaused nonReentrant {
+        require(block.timestamp >= lastBuybackAt + cooldown, "cooldown");
+
+        uint256 ethBalance = address(this).balance;
+        require(ethBalance > 0, "no ETH");
+
+        address;
+        path[0] = router.WETH();
+        path[1] = address(IFR);
+
+        uint256[] memory quoted = router.getAmountsOut(ethBalance, path);
+        require(quoted.length >= 2, "quote");
+        uint256 expectedOut = quoted[quoted.length - 1];
+        require(expectedOut > 0, "expectedOut");
+
+        uint256 minOut = (expectedOut * (BPS_DENOMINATOR - slippageBps)) / BPS_DENOMINATOR;
+
+        uint256[] memory result = router.swapExactETHForTokens{value: ethBalance}(
+            minOut,
+            path,
+            address(this),
+            block.timestamp + 15 minutes
+        );
+        uint256 received = result[result.length - 1];
+        require(received >= minOut, "slippage");
+
+        uint256 burnAmount = (received * burnShareBps) / BPS_DENOMINATOR;
+        uint256 treasuryAmount = received - burnAmount;
+
+        if (burnAmount > 0) {
+            IFR.safeTransfer(burnReserve, burnAmount);
+        }
+        if (treasuryAmount > 0) {
+            IFR.safeTransfer(treasury, treasuryAmount);
+        }
+
+        lastBuybackAt = block.timestamp;
+        emit BuybackExecuted(ethBalance, received, burnAmount, treasuryAmount);
+    }
+
+    // ---- Admin ----
+    function setParams(
+        uint256 _burnShareBps,
+        uint256 _cooldown,
+        uint256 _slippageBps,
+        address _router,
+        address _treasury
+    ) external onlyOwner {
+        require(_burnShareBps <= BPS_DENOMINATOR, "burn>100%");
+        require(_slippageBps <= BPS_DENOMINATOR, "slippage>100%");
+        require(_router != address(0), "router zero");
+        require(_treasury != address(0), "treasury zero");
+
+        burnShareBps = _burnShareBps;
+        cooldown = _cooldown;
+        slippageBps = _slippageBps;
+        router = IUniV2RouterLike(_router);
+        treasury = _treasury;
+
+        emit ParamsUpdated(_burnShareBps, _cooldown, _slippageBps, _router, _treasury);
+    }
+
+    function setGuardian(address _guardian) external onlyOwner {
+        require(_guardian != address(0), "guardian zero");
+        guardian = _guardian;
+        emit GuardianUpdated(_guardian);
+    }
+
+    // ---- Pause ----
+    function pause() external onlyGuardianOrOwner {
+        require(!_paused, "Pausable: paused");
+        _paused = true;
+        emit Paused(msg.sender);
+    }
+
+    function unpause() external onlyGuardianOrOwner {
+        require(_paused, "Pausable: not paused");
+        _paused = false;
+        emit Unpaused(msg.sender);
+    }
+}
diff --git a/logs/project.log b/logs/project.log
--- a/logs/project.log
+++ b/logs/project.log
@@ -1,4 +1,5 @@
 [2025-09-23 23:15] Dev4 FEATURE â€“ Vesting Contract â€“ Vesting.sol + Tests + Deploy + ABI abgeschlossen und dokumentiert (Vesting ðŸŸ¢)
+[2025-09-26 16:05] Main DEVA FEATURE â€“ BuybackVault Contract hinzugefÃ¼gt (Datei erstellt, Tests folgen) (Patch 050)
*** End Patch
